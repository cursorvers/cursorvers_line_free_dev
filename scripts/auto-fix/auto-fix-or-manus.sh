#!/bin/bash
set -euo pipefail

AUDIT_BODY_PATH="${1:-}"
AUDIT_MODE="${2:-unknown}"
AUDIT_HTTP_CODE="${3:-unknown}"

if [ -z "$AUDIT_BODY_PATH" ] || [ ! -f "$AUDIT_BODY_PATH" ]; then
  echo "Audit body file not found: $AUDIT_BODY_PATH"
  exit 1
fi

AUDIT_BODY=$(cat "$AUDIT_BODY_PATH")
ERROR_INFO=$(bash scripts/auto-fix/detect-errors.sh "$AUDIT_BODY")
ERROR_TYPE=$(echo "$ERROR_INFO" | jq -r '.error_type')
FIX_SCRIPT=$(echo "$ERROR_INFO" | jq -r '.fix_script')

TIMESTAMP=$(date +%Y-%m-%d-%H%M%S)
mkdir -p docs/logs/errors docs/logs/fixes
ERROR_LOG="docs/logs/errors/error-${TIMESTAMP}.json"
echo "$ERROR_INFO" > "$ERROR_LOG"

AUTO_FIX_APPLIED=false
AUTO_FIX_STATUS="skipped"

if [ "$FIX_SCRIPT" = "fix-auth-headers.sh" ] || [ "$FIX_SCRIPT" = "fix-yaml-syntax.sh" ]; then
  if bash "scripts/auto-fix/$FIX_SCRIPT"; then
    AUTO_FIX_APPLIED=true
    AUTO_FIX_STATUS="success"
  else
    AUTO_FIX_STATUS="failed"
  fi
fi

MANUS_TRIGGERED=false
MANUS_TASK_URL=""
MANUS_ERROR=""

if [ "$AUTO_FIX_APPLIED" != "true" ]; then
  if [ -z "${MANUS_API_KEY:-}" ]; then
    MANUS_ERROR="MANUS_API_KEY not set"
  else
    PLAN_PATH=$(mktemp)
    AUDIT_EXCERPT=$(echo "$AUDIT_BODY" | head -c 1500)
    PLAN_JSON=$(jq -n \
      --arg title "Auto-fix audit failure (${AUDIT_MODE})" \
      --arg mode "$AUDIT_MODE" \
      --arg error_type "$ERROR_TYPE" \
      --arg http_code "$AUDIT_HTTP_CODE" \
      --arg excerpt "$AUDIT_EXCERPT" \
      --arg repo "${GITHUB_REPOSITORY:-}" \
      '{
        title: $title,
        version: "1.0.0",
        risk: {
          level: "medium",
          reasons: ["audit_failure", $error_type]
        },
        steps: [
          {
            id: "s1",
            action: "analyze.audit_failure",
            payload: {
              mode: $mode,
              error_type: $error_type,
              http_code: $http_code
            },
            on_error: "abort"
          },
          {
            id: "s2",
            action: "review.audit_payload",
            payload: {
              excerpt: $excerpt
            },
            on_error: "abort"
          },
          {
            id: "s3",
            action: "propose.fix",
            payload: {
              repository: $repo
            },
            on_error: "abort"
          },
          {
            id: "s4",
            action: "implement.fix",
            payload: {
              repository: $repo
            },
            on_error: "abort"
          },
          {
            id: "s5",
            action: "verify",
            payload: {
              checks: ["rerun audit", "review logs"]
            },
            on_error: "continue"
          },
          {
            id: "s6",
            action: "report",
            payload: {
              channels: ["github", "discord"]
            },
            on_error: "continue"
          }
        ],
        observability: {
          notes: ["auto-generated by audit workflow"]
        }
      }')
    echo "$PLAN_JSON" > "$PLAN_PATH"
    MANUS_OUTPUT=$(node scripts/manus-api.js create "orchestration/MANUS_AUTO_FIX_BRIEF.md" "$PLAN_PATH")
    MANUS_TASK_URL=$(echo "$MANUS_OUTPUT" | awk -F': ' '/Task URL/ {print $2}' | tail -n 1 | tr -d '\r')
    rm -f "$PLAN_PATH"
    if [ -n "$MANUS_TASK_URL" ]; then
      MANUS_TRIGGERED=true
    fi
  fi
fi

FIX_LOG="docs/logs/fixes/fix-${TIMESTAMP}.md"
cat > "$FIX_LOG" <<EOF
# Auto Fix Result

- mode: $AUDIT_MODE
- error_type: $ERROR_TYPE
- http_code: $AUDIT_HTTP_CODE
- fix_script: $FIX_SCRIPT
- auto_fix_status: $AUTO_FIX_STATUS
- manus_triggered: $MANUS_TRIGGERED
- manus_task_url: ${MANUS_TASK_URL}
- manus_error: ${MANUS_ERROR}
EOF

if [ -n "${GITHUB_OUTPUT:-}" ]; then
  echo "error_type=$ERROR_TYPE" >> "$GITHUB_OUTPUT"
  echo "fix_script=$FIX_SCRIPT" >> "$GITHUB_OUTPUT"
  echo "auto_fix_applied=$AUTO_FIX_APPLIED" >> "$GITHUB_OUTPUT"
  echo "manus_triggered=$MANUS_TRIGGERED" >> "$GITHUB_OUTPUT"
  if [ -n "$MANUS_TASK_URL" ]; then
    echo "manus_task_url=$MANUS_TASK_URL" >> "$GITHUB_OUTPUT"
  fi
fi
